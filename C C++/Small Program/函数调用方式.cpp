// 调用方式

// 有时候我们会在函数声明时看到 __stdcall , __cdecl, 等等
// 那么他们是什么意思呢;

// 其实他们是一种"调用方式"的约定,

// __cdecl是C/C++此程序的缺省调用方式 参数采用从右到左的压栈方式 传送参数的内存栈由调用者维护

// __stdcall是Pascal程序的缺省调用方式 参数采用从右到左的压栈方式 被调函数自身在返回前清空堆栈
// ( 对于Win32API程序 他默认使用的就是这种调用方式 );


// 对于每一个Win32API程序 我们总希望把他写成__stdcall

// Windows的函数调用时需要用到栈
// 当函数调用完成后 栈需要清除 这里就是问题的关键 如何清除 ?

// 如果我们的函数使用了__cdecl 那么栈的清除工作是由调用者 说的俗点就是程序员来做
// 这样带来了一个棘手的问题 不同的编译器产生栈的方式不尽相同 那么调用者能否正常的完成清除工作呢 答案是不能

// 如果使用__stdcall 上面的问题就解决了 函数自己解决清除工作 
// 所以在跨平台的调用中 我们都使用__stdcall

// 那么为什么还需要__cdecl呢 ? 当我们遇到这样的函数如fprintf()它的参数是可变的 不定长的 
// 被调用者事先无法知道参数的长度 事后的清除工作也无法正常的进行 因此 这种情况我们只能使用__cdecl

// 到这里我们有一个结论 如果程序中没有涉及可变参数 最好使用__stdcall关键字



// __cdecl是C/C++缺省的调用方式: 一下两者等价,
// void Input( int &m, int &n);
// void __cdecl Input( int &m, int &n);

// 汇编代码( "调用者"的汇编 )

	// int i = 1;
// 00113658  mov         dword ptr [i],1  
	// int j = 2;
// 0011365F  mov         dword ptr [j],2  
	// Func( i, j );
// 00113666  lea         eax,[j]  
// 00113669  push        eax  
// 0011366A  lea         ecx,[i]  
// 0011366D  push        ecx  
// 0011366E  call        Func (01114C9h)  
// 00113673  add         esp,8  

// 对此汇编代码分析:
// 首先定义了一个int i = 1; 把ptr[i] 设置为1; 同理设置了ptr[j];

// 首先取[j]的偏移地址,然后把这个偏移地址入栈 然后取[i]的偏移地址,然后把这个偏移地址入栈
// 然后调用了函数 Func
// 调用结束之后把栈顶指针esp加8 因为入了两个地址 所以栈顶加了8 
// ( 入的是两个偏移地址 相当于引用, 一个引用(地址)占用4字节 函数会自动计算需要清理多少内存 )
// ( 这个方式是 由 "调用者" 来清理栈, 这是__cdecl的特征之一 ); 

// 然后由上可以看出来:
// 对于__cdecl 压栈顺序为从右到左( 先压入了j的偏移地址, 在压入了i的偏移地址 )
// 由于实参是相应变量的引用 所以栈压入的是变量的偏移地址( 类似于指针 )
// 此时如果在函数内修改了变量值 则实参也会变化;

// 汇编代码:( "被调用者" 汇编 )
// {
// .................................
	// m++;
// 00AC3F5E  mov         eax,dword ptr [m]  
// 00AC3F61  mov         ecx,dword ptr [eax]  
// 00AC3F63  add         ecx,1  
// 00AC3F66  mov         edx,dword ptr [m]  
// 00AC3F69  mov         dword ptr [edx],ecx  
	// n++;
// 00AC3F6B  mov         eax,dword ptr [n]  
// 00AC3F6E  mov         ecx,dword ptr [eax]  
// 00AC3F70  add         ecx,1  
// 00AC3F73  mov         edx,dword ptr [n]  
// 00AC3F76  mov         dword ptr [edx],ecx  
// }
// 00AC3F78  pop         edi  
// 00AC3F79  pop         esi  
// 00AC3F7A  pop         ebx  
// 00AC3F7B  mov         esp,ebp  
// 00AC3F7D  pop         ebp  
// 00AC3F7E  ret  

// 其中省略了一部分代码 在函数逻辑代码完成之后 有4个pop 
// 这四个pop弹出的是一些在函数内被压入的变量( 这里被省略了 是在省略号里的 没有影响 )
// 这个ret是出栈 然后把值给了ip寄存器 然后程序跳转到ip的地方;
// 这里其实就被调用者来说 他并没有使用栈( 或者说使用完毕但是已经归还了 )
// 但是压入的数据没有清除 所以这个任务交给了"调用者"

// ------------------小插曲
// 如果此时我们使用的不是引用 会怎么样 就像
// void __cdecl Input( int m, int n, int k );

// 汇编代码:( "调用者" 汇编 )

	// int i = 1;
// 0098323E  mov         dword ptr [i],1  
	// int j = 2;
// 00983245  mov         dword ptr [j],2  
	// int k = 3;
// 0098324C  mov         dword ptr [k],3  
	// Func( i, j, k );
// 00983253  mov         eax,dword ptr [k]  
// 00983256  push        eax  
// 00983257  mov         ecx,dword ptr [j]  
// 0098325A  push        ecx  
// 0098325B  mov         edx,dword ptr [i]  
// 0098325E  push        edx  
// 0098325F  call        Func (09814D8h)  
// 00983264  add         esp,0Ch  

// 在这个函数里我们使用了3个变量i j k 所以按照__cdecl的规则 应该先压入k 在压入j 在压入i 这是合理的
// 在看 在传引用的时候 我们压入栈里的是变量的偏移地址( 取的lea ), 
// 而在传值这里 他是把变量的一份copy放入了eax寄存器 然后把eax寄存器里的内容压栈 
// 这就解释了为什么传值调用无法改变变量本身 因为函数最后栈中得到的只是变量的一份copy
// 压栈结束 调用函数, 然后清理栈 因为压入了3个int类型变量 所以清理12个字节 
// ( 对于一个point是4字节 一个int也是4字节 第一个函数清理了2个point,而这个函数清理了3个int )

// /----------------------------------------------------------------------------------------//

// __stdcall是Pascal程序的缺省的调用方式: ( 一般用于Win32API程序 )
// void __stdcall Func( int &m, int &n );

// 汇编代码:( "调用者" 汇编 )

	// int i = 1;
// 000D3248  mov         dword ptr [i],1  
	// int j = 2;
// 000D324F  mov         dword ptr [j],2  

	// Func( i, j );
// 000D3256  lea         eax,[j]  
// 000D3259  push        eax  
// 000D325A  lea         ecx,[i]  
// 000D325D  push        ecx  
// 000D325E  call        Func (0D14DDh)  

// 分析:
// 这个汇编代码和上面对应的__cdecl几乎一样 都是从右往左数据压栈
// 唯一的区别就是 少了一个清空栈的操作 因为这个操作是由被调函数完成的

// 以下是"被调函数" 汇编:
// {
// ...................
	// m++;
// 00E9483E  mov         eax,dword ptr [m]  
// 00E94841  mov         ecx,dword ptr [eax]  
// 00E94843  add         ecx,1  
// 00E94846  mov         edx,dword ptr [m]  
// 00E94849  mov         dword ptr [edx],ecx  
	// n++;
// 00E9484B  mov         eax,dword ptr [n]  
// 00E9484E  mov         ecx,dword ptr [eax]  
// 00E94850  add         ecx,1  
// 00E94853  mov         edx,dword ptr [n]  
// 00E94856  mov         dword ptr [edx],ecx  
// }
// 00E94858  pop         edi  
// 00E94859  pop         esi  
// 00E9485A  pop         ebx  
// 00E9485B  mov         esp,ebp  
// 00E9485D  pop         ebp  
// 00E9485E  ret         8  


// 其中省略了一部分代码 在函数逻辑代码完成之后 有4个pop 
// 这四个pop弹出的是一些在函数内被压入的变量( 这里被省略了 是在省略号里的 没有影响 )
// 然后ret才是真正的清栈, ( ret的意思是 弹出字节 然后给ip寄存器 作为下一条指令的地址 )
// 那么我们装入了两个int类型的引用( 在调用函数里push的是lea偏移地址 ) 所以pop 出8个字节
// 然后把栈顶作为偏移地址 即回到了调用处; 与__cdecl不同 这个是由"被调用者"清栈


// /--------------------------------------------------------------------------/


// 总结:
// __cdecl		是C/C++的默认调用方式		变量从右往左入栈, 由"调用者"清栈 ( 可变参数只能用他 )
// __stdcall	是Win32API的默认调用方式	变量从右往左入栈, 由"被调用者"清栈 ( 可执行文件小 )


